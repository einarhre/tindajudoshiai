<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README.lwsws</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="notes-about-lwsws">Notes about lwsws</h1>
<p><span class="citation" data-cites="section">@section</span> lwsws Libwebsockets Web Server</p>
<p>lwsws is an implementation of a very lightweight, ws-capable generic web server, which uses libwebsockets to implement everything underneath.</p>
<p>If you are basically implementing a standalone server with lws, you can avoid reinventing the wheel and use a debugged server including lws.</p>
<p><span class="citation" data-cites="section">@section</span> lwswsb Build</p>
<p>Just enable -DLWS_WITH_LWSWS=1 at cmake-time.</p>
<p>It enables libuv and plugin support automatically.</p>
<p>NOTICE on Ubuntu, the default libuv package is called “libuv-0.10”. This is ancient.</p>
<p>You should replace this with libuv1 and libuv1-dev before proceeding.</p>
<p><span class="citation" data-cites="section">@section</span> lwswsc Lwsws Configuration</p>
<p>lwsws uses JSON config files, they’re pure JSON except:</p>
<ul>
<li><p>‘#’ may be used to turn the rest of the line into a comment.</p></li>
<li><p>There’s also a single substitution, if a string contains “<em>lws_ddir</em>”, then that is replaced with the LWS install data directory path, eg, “/usr/share” or whatever was set when LWS was built + installed. That lets you refer to installed paths without having to change the config if your install path was different.</p></li>
</ul>
<p>There is a single file intended for global settings</p>
<p>/etc/lwsws/conf</p>
<pre><code>    # these are the server global settings
    # stuff related to vhosts should go in one
    # file per vhost in ../conf.d/

    {
      &quot;global&quot;: {
       &quot;username&quot;: &quot;apache&quot;,
       &quot;groupname&quot;: &quot;apache&quot;,
       &quot;count-threads&quot;: &quot;1&quot;,
       &quot;server-string&quot;: &quot;myserver v1&quot;, # returned in http headers
       &quot;ws-pingpong-secs&quot;: &quot;200&quot;, # confirm idle established ws connections this often
       &quot;init-ssl&quot;: &quot;yes&quot;
     }
    }</code></pre>
<p>and a config directory intended to take one file per vhost</p>
<p>/etc/lwsws/conf.d/warmcat.com</p>
<pre><code>    {
        &quot;vhosts&quot;: [{
            &quot;name&quot;: &quot;warmcat.com&quot;,
            &quot;port&quot;: &quot;443&quot;,
            &quot;interface&quot;: &quot;eth0&quot;,  # optional
            &quot;host-ssl-key&quot;: &quot;/etc/pki/tls/private/warmcat.com.key&quot;,  # if given enable ssl
            &quot;host-ssl-cert&quot;: &quot;/etc/pki/tls/certs/warmcat.com.crt&quot;,
            &quot;host-ssl-ca&quot;: &quot;/etc/pki/tls/certs/warmcat.com.cer&quot;,
            &quot;mounts&quot;: [{  # autoserve
                &quot;mountpoint&quot;: &quot;/&quot;,
                &quot;origin&quot;: &quot;file:///var/www/warmcat.com&quot;,
                &quot;default&quot;: &quot;index.html&quot;
            }]
        }]
    }</code></pre>
<p>To get started quickly, an example config reproducing the old test server on port 7681, non-SSL is provided. To set it up</p>
<pre><code>    # mkdir -p /etc/lwsws/conf.d /var/log/lwsws
    # cp ./lwsws/etc-lwsws-conf-EXAMPLE /etc/lwsws/conf
    # cp ./lwsws/etc-lwsws-conf.d-localhost-EXAMPLE /etc/lwsws/conf.d/test-server
    # sudo lwsws</code></pre>
<p><span class="citation" data-cites="section">@section</span> lwswsacme Using Letsencrypt or other ACME providers</p>
<p>Lws supports automatic provisioning and renewal of TLS certificates.</p>
<p>See ./READMEs/README.plugin-acme.md for examples of how to set it up on an lwsws vhost.</p>
<p><span class="citation" data-cites="section">@section</span> lwsogo Other Global Options</p>
<ul>
<li><code>reject-service-keywords</code> allows you to return an HTTP error code and message of your choice if a keyword is found in the user agent</li>
</ul>
<pre><code>   &quot;reject-service-keywords&quot;: [{
        &quot;scumbot&quot;: &quot;404 Not Found&quot;
   }]</code></pre>
<ul>
<li><code>timeout-secs</code> lets you set the global timeout for various network-related operations in lws, in seconds. It defaults to 5.</li>
</ul>
<p><span class="citation" data-cites="section">@section</span> lwswsv Lwsws Vhosts</p>
<p>One server can run many vhosts, where SSL is in use SNI is used to match the connection to a vhost and its vhost-specific SSL keys during SSL negotiation.</p>
<p>Listing multiple vhosts looks something like this</p>
<pre><code>    {
     &quot;vhosts&quot;: [ {
         &quot;name&quot;: &quot;localhost&quot;,
         &quot;port&quot;: &quot;443&quot;,
         &quot;host-ssl-key&quot;:  &quot;/etc/pki/tls/private/libwebsockets.org.key&quot;,
         &quot;host-ssl-cert&quot;: &quot;/etc/pki/tls/certs/libwebsockets.org.crt&quot;,
         &quot;host-ssl-ca&quot;:   &quot;/etc/pki/tls/certs/libwebsockets.org.cer&quot;,
         &quot;mounts&quot;: [{
           &quot;mountpoint&quot;: &quot;/&quot;,
           &quot;origin&quot;: &quot;file:///var/www/libwebsockets.org&quot;,
           &quot;default&quot;: &quot;index.html&quot;
           }, {
            &quot;mountpoint&quot;: &quot;/testserver&quot;,
            &quot;origin&quot;: &quot;file:///usr/local/share/libwebsockets-test-server&quot;,
            &quot;default&quot;: &quot;test.html&quot;
           }],
         # which protocols are enabled for this vhost, and optional
         # vhost-specific config options for the protocol
         #
         &quot;ws-protocols&quot;: [{
           &quot;warmcat,timezoom&quot;: {
             &quot;status&quot;: &quot;ok&quot;
           }
         }]
        },
        {
        &quot;name&quot;: &quot;localhost&quot;,
        &quot;port&quot;: &quot;7681&quot;,
         &quot;host-ssl-key&quot;:  &quot;/etc/pki/tls/private/libwebsockets.org.key&quot;,
         &quot;host-ssl-cert&quot;: &quot;/etc/pki/tls/certs/libwebsockets.org.crt&quot;,
         &quot;host-ssl-ca&quot;:   &quot;/etc/pki/tls/certs/libwebsockets.org.cer&quot;,
         &quot;mounts&quot;: [{
           &quot;mountpoint&quot;: &quot;/&quot;,
           &quot;origin&quot;: &quot;&gt;https://localhost&quot;
         }]
       },
        {
        &quot;name&quot;: &quot;localhost&quot;,
        &quot;port&quot;: &quot;80&quot;,
         &quot;mounts&quot;: [{
           &quot;mountpoint&quot;: &quot;/&quot;,
           &quot;origin&quot;: &quot;&gt;https://localhost&quot;
         }]
       }
    
      ]
    }</code></pre>
<p>That sets up three vhosts all called “localhost” on ports 443 and 7681 with SSL, and port 80 without SSL but with a forced redirect to https://localhost</p>
<p><span class="citation" data-cites="section">@section</span> lwswsvn Lwsws Vhost name and port sharing</p>
<p>The vhost name field is used to match on incoming SNI or Host: header, so it must always be the host name used to reach the vhost externally.</p>
<ul>
<li><p>Vhosts may have the same name and different ports, these will each create a listening socket on the appropriate port.</p></li>
<li><p>Vhosts may also have the same port and different name: these will be treated as true vhosts on one listening socket and the active vhost decided at SSL negotiation time (via SNI) or if no SSL, then after the Host: header from the client has been parsed.</p></li>
</ul>
<p><span class="citation" data-cites="section">@section</span> lwswspr Lwsws Protocols</p>
<p>Vhosts by default have available the union of any initial protocols from context creation time, and any protocols exposed by plugins.</p>
<p>Vhosts can select which plugins they want to offer and give them per-vhost settings using this syntax</p>
<pre><code>         &quot;ws-protocols&quot;: [{
           &quot;warmcat-timezoom&quot;: {
             &quot;status&quot;: &quot;ok&quot;
           }
         }]</code></pre>
<p>The “x”:“y” parameters like “status”:“ok” are made available to the protocol during its per-vhost LWS_CALLBACK_PROTOCOL_INIT (in is a pointer to a linked list of struct lws_protocol_vhost_options containing the name and value pointers).</p>
<p>To indicate that a protocol should be used when no Protocol: header is sent by the client, you can use “default”: “1”</p>
<pre><code>         &quot;ws-protocols&quot;: [{
           &quot;warmcat-timezoom&quot;: {
             &quot;status&quot;: &quot;ok&quot;,
             &quot;default&quot;: &quot;1&quot;
           }
         }]</code></pre>
<p>Similarly, if your vhost is serving a raw protocol, you can mark the protocol to be selected using “raw”: “1”</p>
<pre><code>         &quot;ws-protocols&quot;: [{
           &quot;warmcat-timezoom&quot;: {
             &quot;status&quot;: &quot;ok&quot;,
             &quot;raw&quot;: &quot;1&quot;
           }
         }]</code></pre>
<p>See also “apply-listen-accept” below.</p>
<p><span class="citation" data-cites="section">@section</span> lwswsovo Lwsws Other vhost options</p>
<ul>
<li>If the three options <code>host-ssl-cert</code>, <code>host-ssl-ca</code> and <code>host-ssl-key</code> are given, then the vhost supports SSL.</li>
</ul>
<p>Each vhost may have its own certs, SNI is used during the initial connection negotiation to figure out which certs to use by the server name it’s asking for from the request DNS name.</p>
<ul>
<li><p><code>keeplive-timeout</code> (in secs) defaults to 60 for lwsws, it may be set as a vhost option</p></li>
<li><p><code>interface</code> lets you specify which network interface to listen on, if not given listens on all. If the network interface is not usable (eg, ethernet cable out) it will be logged at startup with such vhost not listening, and lws will poll for it and bind a listen socket to the interface if and when it becomes available.</p></li>
<li><p>“<code>unix-socket</code>”: “1” causes the unix socket specified in the interface option to be used instead of an INET socket</p></li>
<li><p>“<code>unix-socket-perms</code>”: “user:group” allows you to control the unix permissons on the listening unix socket. It’s always get to <code>0600</code> mode, but you can control the user and group for the socket fd at creation time. This allows you to use unix user and groups to control who may open the other end of the unix socket on the local system.</p></li>
<li><p>“<code>sts</code>”: “1” causes lwsws to send a Strict Transport Security header with responses that informs the client he should never accept to connect to this address using http. This is needed to get the A+ security rating from SSL Labs for your server.</p></li>
<li><p>“<code>access-log</code>”: “filepath” sets where apache-compatible access logs will be written</p></li>
<li><p><code>"enable-client-ssl"</code>: <code>"1"</code> enables the vhost’s client SSL context, you will need this if you plan to create client conections on the vhost that will use SSL. You don’t need it if you only want http / ws client connections.</p></li>
<li><p>“<code>ciphers</code>”: “<cipher list>” OPENSSL only: sets the allowed list of TLS &lt;= 1.2 ciphers and key exchange protocols for the serving SSL_CTX on the vhost. The default list is restricted to only those providing PFS (Perfect Forward Secrecy) on the author’s Fedora system.</p></li>
</ul>
<p>If you need to allow weaker ciphers, you can provide an alternative list here per-vhost.</p>
<ul>
<li><p>“<code>client-ssl-ciphers</code>”: “<cipher list>” OPENSSL only: sets the allowed list of &lt;= TLS1.2 ciphers and key exchange protocols for the client SSL_CTX on the vhost</p></li>
<li><p>“<code>tls13-ciphers</code>”: “<cipher list>” OPENSSL 1.1.1+ only: sets allowed list of TLS1.3+ ciphers and key exchange protocols for the client SSL_CTX on the vhost. The default is to allow all.</p></li>
<li><p>“<code>client-tls13-ciphers</code>”: “<cipher list>” OPENSSL 1.1.1+ only: sets the allowed list of TLS1.3+ ciphers and key exchange protocols for the client SSL_CTX on the vhost. The default is to allow all.</p></li>
<li><p>“<code>ecdh-curve</code>”: “<curve name>” The default ecdh curve is “prime256v1”, but you can override it here, per-vhost</p></li>
<li><p>“<code>noipv6</code>”: “on” Disable ipv6 completely for this vhost</p></li>
<li><p>“<code>ipv6only</code>”: “on” Only allow ipv6 on this vhost / “off” only allow ipv4 on this vhost</p></li>
<li><p>“<code>ssl-option-set</code>”: “<decimal>” Sets the SSL option flag value for the vhost. It may be used multiple times and OR’s the flags together.</p></li>
</ul>
<p>The values are derived from /usr/include/openssl/ssl.h</p>
<pre><code>     # define SSL_OP_NO_TLSv1_1                               0x10000000L</code></pre>
<p>would equate to</p>
<pre><code>     &quot;`ssl-option-set`&quot;: &quot;268435456&quot;</code></pre>
<ul>
<li><p>“`ssl-option-clear’”: “<decimal>” Clears the SSL option flag value for the vhost. It may be used multiple times and OR’s the flags together.</p></li>
<li><p>“<code>ssl-client-option-set</code>” and “<code>ssl-client-option-clear</code>” work the same way for the vhost Client SSL context</p></li>
<li><p>"`headers’:: [{ “header1”: “h1value”, “header2”: “h2value” }]</p></li>
</ul>
<p>allows you to set arbitrary headers on every file served by the vhost</p>
<p>recommended vhost headers for good client security are</p>
<pre><code>                   &quot;headers&quot;: [{
                        &quot;Content-Security-Policy&quot;: &quot;script-src &#39;self&#39;&quot;,
                        &quot;X-Content-Type-Options&quot;: &quot;nosniff&quot;,
                        &quot;X-XSS-Protection&quot;: &quot;1; mode=block&quot;,
                        &quot;X-Frame-Options&quot;: &quot;SAMEORIGIN&quot;
                 }]
</code></pre>
<ul>
<li>“<code>apply-listen-accept</code>”: “on” This vhost only serves a non-http protocol, specified in “listen-accept-role” and “listen-accept-protocol”</li>
</ul>
<p><span class="citation" data-cites="section">@section</span> lwswsm Lwsws Mounts</p>
<p>Where mounts are given in the vhost definition, then directory contents may be auto-served if it matches the mountpoint.</p>
<p>Mount protocols are used to control what kind of translation happens</p>
<ul>
<li>file:// serve the uri using the remainder of the url past the mountpoint based on the origin directory.</li>
</ul>
<p>Eg, with this mountpoint</p>
<pre><code>           {
            &quot;mountpoint&quot;: &quot;/&quot;,
            &quot;origin&quot;: &quot;file:///var/www/mysite.com&quot;,
            &quot;default&quot;: &quot;/&quot;
           }</code></pre>
<p>The uri /file.jpg would serve /var/www/mysite.com/file.jpg, since / matched.</p>
<ul>
<li><p>^http:// or ^https:// these cause any url matching the mountpoint to issue a redirect to the origin url</p></li>
<li>cgi:// this causes any matching url to be given to the named cgi, eg</li>
</ul>
<pre><code>           {
            &quot;mountpoint&quot;: &quot;/git&quot;,
            &quot;origin&quot;: &quot;cgi:///var/www/cgi-bin/cgit&quot;,
            &quot;default&quot;: &quot;/&quot;
           }, {
            &quot;mountpoint&quot;: &quot;/cgit-data&quot;,
            &quot;origin&quot;: &quot;file:///usr/share/cgit&quot;,
            &quot;default&quot;: &quot;/&quot;
           },</code></pre>
<p>would cause the url /git/myrepo to pass “myrepo” to the cgi /var/www/cgi-bin/cgit and send the results to the client.</p>
<ul>
<li>http:// or https:// these perform reverse proxying, serving the remote origin content from the mountpoint. Eg</li>
</ul>
<pre><code>        {
         &quot;mountpoint&quot;: &quot;/proxytest&quot;,
         &quot;origin&quot;: &quot;https://libwebsockets.org&quot;
        }</code></pre>
<p>This will cause your local url <code>/proxytest</code> to serve content fetched from libwebsockets.org over ssl; whether it’s served from your server using ssl is unrelated and depends how you configured your local server. Notice if you will use the proxying feature, <code>LWS_WITH_HTTP_PROXY</code> is required to be enabled at cmake, and for <code>https</code> proxy origins, your lwsws configuration must include <code>"init-ssl": "1"</code> and the vhost with the proxy mount must have <code>"enable-client-ssl": "1"</code>, even if you are not using ssl to serve.</p>
<p><code>/proxytest/abc</code>, or <code>/proxytest/abc?def=ghi</code> etc map to the origin + the part past <code>/proxytest</code>, so links and img src urls etc work as do all urls under the origin path.</p>
<p>In addition link and src urls in the document are rewritten so / or the origin url part are rewritten to the mountpoint part.</p>
<p><span class="citation" data-cites="section">@section</span> lwswsomo Lwsws Other mount options</p>
<ol type="1">
<li><p>Some protocols may want “per-mount options” in name:value format. You can provide them using “pmo”</p>
<pre><code>    {
     &quot;mountpoint&quot;: &quot;/stuff&quot;,
     &quot;origin&quot;: &quot;callback://myprotocol&quot;,
     &quot;pmo&quot;: [{
             &quot;myname&quot;: &quot;myvalue&quot;
     }]
    }</code></pre></li>
<li>When using a cgi:// protocol origin at a mountpoint, you may also give cgi environment variables specific to the mountpoint like this</li>
</ol>
<pre><code>           {
            &quot;mountpoint&quot;: &quot;/git&quot;,
            &quot;origin&quot;: &quot;cgi:///var/www/cgi-bin/cgit&quot;,
            &quot;default&quot;: &quot;/&quot;,
            &quot;cgi-env&quot;: [{
                    &quot;CGIT_CONFIG&quot;: &quot;/etc/cgitrc/libwebsockets.org&quot;
            }]
           }</code></pre>
<p>This allows you to customize one cgi depending on the mountpoint (and / or vhost).</p>
<ol start="3" type="1">
<li>It’s also possible to set the cgi timeout (in secs) per cgi:// mount, like this</li>
</ol>
<pre><code>    &quot;cgi-timeout&quot;: &quot;30&quot;</code></pre>
<ol start="4" type="1">
<li><code>callback://</code> protocol may be used when defining a mount to associate a named protocol callback with the URL namespace area. For example</li>
</ol>
<pre><code>           {
            &quot;mountpoint&quot;: &quot;/formtest&quot;,
            &quot;origin&quot;: &quot;callback://protocol-post-demo&quot;
           }</code></pre>
<p>All handling of client access to /formtest[anything] will be passed to the callback registered to the protocol “protocol-post-demo”.</p>
<p>This is useful for handling POST http body content or general non-cgi http payload generation inside a plugin.</p>
<p>See the related notes in README.coding.md</p>
<ol start="5" type="1">
<li>Cache policy of the files in the mount can also be set. If no options are given, the content is marked uncacheable.</li>
</ol>
<pre><code>           {
            &quot;mountpoint&quot;: &quot;/&quot;,
            &quot;origin&quot;: &quot;file:///var/www/mysite.com&quot;,
            &quot;cache-max-age&quot;: &quot;60&quot;,      # seconds
            &quot;cache-reuse&quot;: &quot;1&quot;,         # allow reuse at client at all
            &quot;cache-revalidate&quot;: &quot;1&quot;,    # check it with server each time
            &quot;cache-intermediaries&quot;: &quot;1&quot; # allow intermediary caches to hold
           }</code></pre>
<ol start="6" type="1">
<li>You can also define a list of additional mimetypes per-mount</li>
</ol>
<pre><code>            &quot;extra-mimetypes&quot;: {
                     &quot;.zip&quot;: &quot;application/zip&quot;,
                     &quot;.doc&quot;: &quot;text/evil&quot;
             }</code></pre>
<p>Normally a file suffix MUST match one of the canned mimetypes or one of the extra mimetypes, or the file is not served. This adds a little bit of security because even if there is a bug somewhere and the mount dirs are circumvented, lws will not serve, eg, /etc/passwd.</p>
<p>If you provide an extra mimetype entry</p>
<pre><code>        &quot;*&quot;: &quot;&quot;</code></pre>
<p>Then any file is served, if the mimetype was not known then it is served without a Content-Type: header.</p>
<ol start="7" type="1">
<li>A mount can be protected by HTTP Basic Auth. This only makes sense when using https, since otherwise the password can be sniffed.</li>
</ol>
<p>You can add a <code>basic-auth</code> entry on an http mount like this</p>
<pre><code>{
        &quot;mountpoint&quot;: &quot;/basic-auth&quot;,
        &quot;origin&quot;: &quot;file://_lws_ddir_/libwebsockets-test-server/private&quot;,
        &quot;basic-auth&quot;: &quot;/var/www/balogins-private&quot;
}</code></pre>
<p>Before serving anything, lws will signal to the browser that a username / password combination is required, and it will pop up a dialog. When the user has filled it in, lwsws checks the user:password string against the text file named in the <code>basic-auth</code> entry.</p>
<p>The file should contain user:pass one per line</p>
<pre><code>testuser:testpass
myuser:hispass</code></pre>
<p>The file should be readable by lwsws, and for a little bit of extra security not have a file suffix, so lws would reject to serve it even if it could find it on a mount.</p>
<p>After successful authentication, <code>WSI_TOKEN_HTTP_AUTHORIZATION</code> contains the authenticated username.</p>
<p>In the case you want to also protect being able to connect to a ws protocol on a particular vhost by requiring the http part can authenticate using Basic Auth before the ws upgrade, this is also possible. In this case, the “basic-auth”: and filepath to the credentials file is passed as a pvo in the “ws-protocols” section of the vhost definition.</p>
<p><span class="citation" data-cites="section">@section</span> lwswscc Requiring a Client Cert on a vhost</p>
<p>You can make a vhost insist to get a client certificate from the peer before allowing the connection with</p>
<pre><code>    &quot;client-cert-required&quot;: &quot;1&quot;</code></pre>
<p>the connection will only proceed if the client certificate was signed by the same CA as the server has been told to trust.</p>
<p><span class="citation" data-cites="section">@section</span> rawconf Configuring Fallback and Raw vhosts</p>
<p>Lws supports some unusual modes for vhost listen sockets, which may be configured entirely using the JSON per-vhost config language in the related vhost configuration section.</p>
<p>There are three main uses for them</p>
<ol type="1">
<li>A vhost bound to a specific role and protocol, not http. This binds all incoming connections on the vhost listen socket to the “raw-proxy” role and protocol “myprotocol”.</li>
</ol>
<pre><code>    &quot;listen-accept-role&quot;:       &quot;raw-proxy&quot;,
    &quot;listen-accept-protocol&quot;:   &quot;myprotocol&quot;,
    &quot;apply-listen-accept&quot;:      &quot;1&quot;</code></pre>
<ol start="2" type="1">
<li>A vhost that wants to treat noncompliant connections for http or https as belonging to a secondary fallback role and protocol. This causes non-https connections to an https listener to stop being treated as https, to lose the tls wrapper, and bind to role “raw-proxy” and protocol “myprotocol”. For example, connect a browser on your external IP :443 as usual and it serves as normal, but if you have configured the raw-proxy to portforward 127.0.0.1:22, then connecting your ssh client to your external port 443 will instead proxy your sshd over :443 with no http or tls getting in the way.</li>
</ol>
<pre><code>    &quot;listen-accept-role&quot;:       &quot;raw-proxy&quot;,
    &quot;listen-accept-protocol&quot;:   &quot;myprotocol&quot;,
    &quot;fallback-listen-accept&quot;:   &quot;1&quot;,
    &quot;allow-non-tls&quot;:        &quot;1&quot;</code></pre>
<ol start="3" type="1">
<li>A vhost wants to either redirect stray http traffic back to https, or to actually serve http on an https listen socket (this is not recommended since it allows anyone to drop the security assurances of https by accident or design).</li>
</ol>
<pre><code>    &quot;allow-non-tls&quot;:        &quot;1&quot;,
    &quot;redirect-http&quot;:        &quot;1&quot;,</code></pre>
<p>…or,</p>
<pre><code>    &quot;allow-non-tls&quot;:        &quot;1&quot;,
    &quot;allow-http-on-https&quot;:      &quot;1&quot;,</code></pre>
<p><span class="citation" data-cites="section">@section</span> lwswspl Lwsws Plugins</p>
<p>Protcols and extensions may also be provided from “plugins”, these are lightweight dynamic libraries. They are scanned for at init time, and any protocols and extensions found are added to the list given at context creation time.</p>
<p>Protocols receive init (LWS_CALLBACK_PROTOCOL_INIT) and destruction (LWS_CALLBACK_PROTOCOL_DESTROY) callbacks per-vhost, and there are arrangements they can make per-vhost allocations and get hold of the correct pointer from the wsi at the callback.</p>
<p>This allows a protocol to choose to strictly segregate data on a per-vhost basis, and also allows the plugin to handle its own initialization and context storage.</p>
<p>To help that happen conveniently, there are some new apis</p>
<ul>
<li>lws_vhost_get(wsi)</li>
<li>lws_protocol_get(wsi)</li>
<li>lws_callback_on_writable_all_protocol_vhost(vhost, protocol)</li>
<li>lws_protocol_vh_priv_zalloc(vhost, protocol, size)</li>
<li>lws_protocol_vh_priv_get(vhost, protocol)</li>
</ul>
<p>dumb increment, mirror and status protocol plugins are provided as examples.</p>
<p><span class="citation" data-cites="section">@section</span> lwswsplaplp Additional plugin search paths</p>
<p>Packages that have their own lws plugins can install them in their own preferred dir and ask lwsws to scan there by using a config fragment like this, in its own conf.d/ file managed by the other package</p>
<pre><code>    {
      &quot;global&quot;: {
       &quot;plugin-dir&quot;: &quot;/usr/local/share/coherent-timeline/plugins&quot;
      }
    }</code></pre>
<p><span class="citation" data-cites="section">@section</span> lwswsssp lws-server-status plugin</p>
<p>One provided protocol can be used to monitor the server status.</p>
<p>Enable the protocol like this on a vhost’s ws-protocols section</p>
<pre><code>           &quot;lws-server-status&quot;: {
             &quot;status&quot;: &quot;ok&quot;,
             &quot;update-ms&quot;: &quot;5000&quot;
           }</code></pre>
<p><code>"update-ms"</code> is used to control how often updated JSON is sent on a ws link.</p>
<p>And map the provided HTML into the vhost in the mounts section</p>
<pre><code>           {
            &quot;mountpoint&quot;: &quot;/server-status&quot;,
            &quot;origin&quot;: &quot;file:///usr/local/share/libwebsockets-test-server/server-status&quot;,
            &quot;default&quot;: &quot;server-status.html&quot;
           }</code></pre>
<p>You might choose to put it on its own vhost which has “interface”: “lo”, so it’s not externally visible, or use the Basic Auth support to require authentication to access it.</p>
<p><code>"hide-vhosts": "{0 | 1}"</code> lets you control if information about your vhosts is included. Since this includes mounts, you might not want to leak that information, mount names, etc.</p>
<p><code>"filespath":"{path}"</code> lets you give a server filepath which is read and sent to the browser on each refresh. For example, you can provide server temperature information on most Linux systems by giving an appropriate path down /sys.</p>
<p>This may be given multiple times.</p>
<p><span class="citation" data-cites="section">@section</span> lwswsreload Lwsws Configuration Reload</p>
<p>You may send lwsws a <code>HUP</code> signal, by, eg</p>
<pre><code>$ sudo killall -HUP lwsws</code></pre>
<p>This causes lwsws to “deprecate” the existing lwsws process, and remove and close all of its listen sockets, but otherwise allowing it to continue to run, until all of its open connections close.</p>
<p>When a deprecated lwsws process has no open connections left, it is destroyed automatically.</p>
<p>After sending the SIGHUP to the main lwsws process, a new lwsws process, which can pick up the newly-available listen sockets, and use the current configuration files, is automatically started.</p>
<p>The new configuration may differ from the original one in arbitrary ways, the new context is created from scratch each time without reference to the original one.</p>
<p>Notes</p>
<ol type="1">
<li>Protocols that provide a “shared world” like mirror will have as many “worlds” as there are lwsws processes still active. People connected to a deprecated lwsws process remain connected to the existing peers.</li>
</ol>
<p>But any new connections will apply to the new lwsws process, which does not share per-vhost “shared world” data with the deprecated process. That means no new connections on the deprecated context, ie a “shrinking world” for those guys, and a “growing world” for people who connect after the SIGHUP.</p>
<ol start="2" type="1">
<li>The new lwsws process owes nothing to the previous one. It starts with fresh plugins, fresh configuration, fresh root privileges if that how you start it.</li>
</ol>
<p>The plugins may have been updated in arbitrary ways including struct size changes etc, and lwsws or lws may also have been updated arbitrarily.</p>
<ol start="3" type="1">
<li>A root parent process is left up that is not able to do anything except respond to SIGHUP or SIGTERM. Actual serving and network listening etc happens in child processes which use the privileges set in the lwsws config files.</li>
</ol>
<p><span class="citation" data-cites="section">@section</span> lwswssysd Lwsws Integration with Systemd</p>
<p>lwsws needs a service file like this as <code>/usr/lib/systemd/system/lwsws.service</code></p>
<pre><code>[Unit]
Description=Libwebsockets Web Server
After=syslog.target

[Service]
ExecStart=/usr/local/bin/lwsws 
ExecReload=/usr/bin/killall -s SIGHUP lwsws ; sleep 1 ; /usr/local/bin/lwsws
StandardError=null

[Install]
WantedBy=multi-user.target</code></pre>
<p>You can find this prepared in <code>./lwsws/usr-lib-systemd-system-lwsws.service</code></p>
<p><span class="citation" data-cites="section">@section</span> lwswslr Lwsws Integration with logrotate</p>
<p>For correct operation with logrotate, <code>/etc/logrotate.d/lwsws</code> (if that’s where we’re putting the logs) should contain</p>
<pre><code>    /var/log/lwsws/*log {
        copytruncate
        missingok
        notifempty
        delaycompress
    }</code></pre>
<p>You can find this prepared in <code>/lwsws/etc-logrotate.d-lwsws</code></p>
<p>Prepare the log directory like this</p>
<pre><code>    sudo mkdir /var/log/lwsws
    sudo chmod 700 /var/log/lwsws</code></pre>
<p><span class="citation" data-cites="section">@section</span> lwswsgdb Debugging lwsws with gdb</p>
<p>Hopefully you won’t need to debug lwsws itself, but you may want to debug your plugins. start lwsws like this to have everything running under gdb</p>
<pre><code>sudo gdb -ex &quot;set follow-fork-mode child&quot; -ex &quot;run&quot; --args /usr/local/bin/lwsws
</code></pre>
<p>this will give nice backtraces in lwsws itself and in plugins, if they were built with symbols.</p>
<p><span class="citation" data-cites="section">@section</span> lwswsvgd Running lwsws under valgrind</p>
<p>You can just run lwsws under valgrind as usual and get valid results. However the results / analysis part of valgrind runs after the plugins have removed themselves, this means valgrind backtraces into plugin code is opaque, without source-level info because the dynamic library is gone.</p>
<p>There’s a simple workaround, use LD_PRELOAD=&lt;plugin.so&gt; before running lwsws, this has the loader bring the plugin in before executing lwsws as if it was a direct dependency. That means it’s still mapped until the whole process exits after valgtind has done its thing.</p>
</body>
</html>
