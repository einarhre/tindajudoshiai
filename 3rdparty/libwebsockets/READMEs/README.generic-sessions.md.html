<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README.generic-sessions</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="notes-about-generic-sessions-plugin">Notes about generic-sessions Plugin</h1>
<p><span class="citation" data-cites="section">@section</span> gseb Enabling lwsgs for build</p>
<p>Enable at CMake with -DLWS_WITH_GENERIC_SESSIONS=1</p>
<p>This also needs sqlite3 (libsqlite3-dev or similar package)</p>
<p><span class="citation" data-cites="section">@section</span> gsi lwsgs Introduction</p>
<p>The generic-sessions protocol plugin provides cookie-based login authentication for lws web and ws connections.</p>
<p>The plugin handles everything about generic account registration, email verification, lost password, account deletion, and other generic account management.</p>
<p>Other code, in another eg, ws protocol handler, only needs very high-level state information from generic-sessions, ie, which user the client is authenticated as. Everything underneath is managed in generic-sessions.</p>
<ul>
<li><p>random 20-byte session id managed in a cookie</p></li>
<li><p>all information related to the session held at the server, nothing managed clientside</p></li>
<li><p>sqlite3 used at the server to manage active sessions and users</p></li>
<li><p>defaults to creating anonymous sessions with no user associated</p></li>
<li><p>admin account (with user-selectable username) is defined in config with a SHA-1 of the password; rest of the accounts are in sqlite3</p></li>
<li><p>user account passwords stored as salted SHA-1 with additional confounder only stored in the JSON config, not the database</p></li>
<li><p>login, logout, register account + email verification built-in with examples</p></li>
<li><p>in a mount, some file suffixes (ie, .js) can be associated with a protocol for the purposes of rewriting symbolnames. These are read-only copies of logged-in server state.</p></li>
<li><p>When your page fetches .js or other rewritten files from that mount, “$lwsgs_user” and so on are rewritten on the fly using chunked transfer encoding</p></li>
<li><p>Eliminates server-side scripting with a few rewritten symbols and javascript on client side</p></li>
<li><p>32-bit bitfield for authentication sectoring, mounts can provide a mask on the loggin-in session’s associated server-side bitfield that must be set for access.</p></li>
<li><p>No code (just config) required for, eg, private URL namespace that requires login to access.</p></li>
</ul>
<p><span class="citation" data-cites="section">@section</span> gsin Lwsgs Integration to HTML</p>
<p>Only three steps are needed to integrate lwsgs in your HTML.</p>
<ol type="1">
<li><p>lwsgs HTML UI is bundled with the javascript it uses in <code>lwsgs.js</code>, so import that script file in your head section</p></li>
<li><p>define an empty div of id “lwsgs” somewhere</p></li>
<li><p>Call lwsgs_initial() in your page</p></li>
</ol>
<p>That’s it. An example is below</p>
<pre><code>    &lt;html&gt;
     &lt;head&gt;
      &lt;script src=&quot;lwsgs.js&quot;&gt;&lt;/script&gt;
      &lt;style&gt;
         .body { font-size: 12 }
         .gstitle { font-size: 18 }
      &lt;/style&gt;
      &lt;/head&gt;
      &lt;body style=&quot;background-image:url(seats.jpg)&quot;&gt;
        &lt;table style=&quot;width:100%;transition: max-height 2s;&quot;&gt;
         &lt;tr&gt;
          &lt;td style=&quot;vertical-align:top;text-align:left;width=200px&quot;&gt;
           &lt;img src=&quot;lwsgs-logo.png&quot;&gt;
          &lt;/td&gt;
          &lt;td style=&quot;vertical-align:top;float:right&quot;&gt;
        &lt;div id=lwsgs style=&quot;text-align:right;background-color: rgba(255, 255, 255, 0.8);&quot;&gt;&lt;/div&gt;
          &lt;/td&gt;
         &lt;/tr&gt;
        &lt;/table&gt;
       &lt;/form&gt;
       
       &lt;script&gt;lwsgs_initial();&lt;/script&gt;
    
     &lt;/body&gt;
    &lt;/html&gt;</code></pre>
<p><span class="citation" data-cites="section">@section</span> gsof Lwsgs Overall Flow@</p>
<p>When the protocol is initialized, it gets per-vhost information from the config, such as where the sqlite3 databases are to be stored. The admin username and sha-1 of the admin password are also taken from here.</p>
<p>In the mounts using protocol-generic-sessions, a cookie is maintained against any requests; if no cookie was active on the initial request a new session is created with no attached user.</p>
<p>So there should always be an active session after any transactions with the server.</p>
<p>In the example html going to the mount /lwsgs loads a login / register page as the default.</p>
The
<form>
<p>in the login page contains ‘next url’ hidden inputs that let the html ‘program’ where the form handler will go after a successful admin login, a successful user login and a failed login.</p>
<p>After a successful login, the sqlite record at the server for the current session is updated to have the logged-in username associated with it.</p>
<p><span class="citation" data-cites="section">@section</span> gsconf Lwsgs Configuration</p>
<p>“auth-mask” defines the authorization sector bits that must be enabled on the session to gain access.</p>
<p>“auth-mask” 0 is the default.</p>
<ul>
<li>b0 is set if you are logged in as a user at all.</li>
<li>b1 is set if you are logged in with the user configured to be admin</li>
<li>b2 is set if the account has been verified (the account configured for admin is always verified)</li>
<li>b3 is set if your session just did the forgot password flow successfully</li>
</ul>
<pre><code>          {
            # things in here can always be served
            &quot;mountpoint&quot;: &quot;/lwsgs&quot;,
            &quot;origin&quot;: &quot;file:///usr/share/libwebsockets-test-server/generic-sessions&quot;,
            &quot;origin&quot;: &quot;callback://protocol-lws-messageboard&quot;,
            &quot;default&quot;: &quot;generic-sessions-login-example.html&quot;,
            &quot;auth-mask&quot;: &quot;0&quot;,
            &quot;interpret&quot;: {
                    &quot;.js&quot;: &quot;protocol-lws-messageboard&quot;
            }
           }, {
            # things in here can only be served if logged in as a user
            &quot;mountpoint&quot;: &quot;/lwsgs/needauth&quot;,
            &quot;origin&quot;: &quot;file:///usr/share/libwebsockets-test-server/generic-sessions/needauth&quot;,
            &quot;origin&quot;: &quot;callback://protocol-lws-messageboard&quot;,
            &quot;default&quot;: &quot;generic-sessions-login-example.html&quot;,
            &quot;auth-mask&quot;: &quot;5&quot;, # logged in as a verified user
            &quot;interpret&quot;: {
                    &quot;.js&quot;: &quot;protocol-lws-messageboard&quot;
            }
           }, {
            # things in here can only be served if logged in as admin
            &quot;mountpoint&quot;: &quot;/lwsgs/needadmin&quot;,
            &quot;origin&quot;: &quot;file:///usr/share/libwebsockets-test-server/generic-sessions/needadmin&quot;,
            &quot;origin&quot;: &quot;callback://protocol-lws-messageboard&quot;,
            &quot;default&quot;: &quot;generic-sessions-login-example.html&quot;,
            &quot;auth-mask&quot;: &quot;7&quot;, # b2 = verified (by email / or admin), b1 = admin, b0 = logged in with any user name
            &quot;interpret&quot;: {
                    &quot;.js&quot;: &quot;protocol-lws-messageboard&quot;
            }
           }</code></pre>
<p>Note that the name of the real application protocol that uses generic-sessions is used, not generic-sessions itself.</p>
<p>The vhost configures the storage dir, admin credentials and session cookie lifetimes:</p>
<pre><code>         &quot;ws-protocols&quot;: [{
           &quot;protocol-generic-sessions&quot;: {
             &quot;status&quot;: &quot;ok&quot;,
             &quot;admin-user&quot;: &quot;admin&quot;,
    
    # create the pw hash like this (for the example pw, &quot;jipdocesExunt&quot; )
    # $ echo -n &quot;jipdocesExunt&quot; | sha1sum
    # 046ce9a9cca769e85798133be06ef30c9c0122c9 -
    #
    # Obviously ** change this password hash to a secret one before deploying **
    #
             &quot;admin-password-sha1&quot;: &quot;046ce9a9cca769e85798133be06ef30c9c0122c9&quot;,
             &quot;session-db&quot;: &quot;/var/www/sessions/lws.sqlite3&quot;,
             &quot;timeout-idle-secs&quot;: &quot;600&quot;,
         &quot;timeout-anon-idle-secs&quot;: &quot;1200&quot;,
             &quot;timeout-absolute-secs&quot;: &quot;6000&quot;,
    # the confounder is part of the salted password hashes.  If this config
    # file is in a 0700 root:root dir, an attacker with apache credentials
    # will have to get the confounder out of the process image to even try
    # to guess the password hashes.
             &quot;confounder&quot;: &quot;Change to &lt;=31 chars of junk&quot;,
    
             &quot;email-from&quot;: &quot;noreply@example.com&quot;,
             &quot;email-smtp-ip&quot;: &quot;127.0.0.1&quot;,
             &quot;email-expire&quot;: &quot;3600&quot;,
             &quot;email-helo&quot;: &quot;myhost.com&quot;,
             &quot;email-contact-person&quot;: &quot;Set Me &lt;real-person@email.com&gt;&quot;,
             &quot;email-confirm-url-base&quot;: &quot;http://localhost:7681/lwsgs&quot;
           }</code></pre>
<p>The email- related settings control generation of automatic emails for registration and forgotten password.</p>
<ul>
<li><p><code>email-from</code>: The email address automatic emails are sent from</p></li>
<li><p><code>email-smtp-ip</code>: Normally 127.0.0.1, if you have a suitable server on port 25 on your lan you can use this instead here.</p></li>
<li><p><code>email-expire</code>: Seconds that links sent in email will work before being deleted</p></li>
<li><p><code>email-helo</code>: HELO to use when communicating with your SMTP server</p></li>
<li><p><code>email-contact-person</code>: mentioned in the automatic emails as a human who can answer questions</p></li>
<li><p><code>email-confirm-url-base</code>: the URL to start links with in the emails, so the recipient can get back to the web server</p></li>
</ul>
<p>The real protocol that makes use of generic-sessions must also be listed and any configuration it needs given</p>
<pre><code>           &quot;protocol-lws-messageboard&quot;: {
             &quot;status&quot;: &quot;ok&quot;,
             &quot;message-db&quot;: &quot;/var/www/sessions/messageboard.sqlite3&quot;
           },</code></pre>
<p>Notice the real application uses his own sqlite db, no details about how generic-sessions works or how it stores data are available to it.</p>
<p><span class="citation" data-cites="section">@section</span> gspwc Lwsgs Password Confounder</p>
<p>You can also define a per-vhost confounder shown in the example above, used when aggregating the password with the salt when it is hashed. Any attacker will also need to get the confounder along with the database, which you can make harder by making the config dir only eneterable / readable by root.</p>
<p><span class="citation" data-cites="section">@section</span> gsprep Lwsgs Preparing the db directory</p>
<p>You will have to prepare the db directory so it’s suitable for the lwsws user to use, that usually means apache, eg</p>
<pre><code>    # mkdir -p /var/www/sessions
    # chown root:apache /var/www/sessions
    # chmod 770 /var/www/sessions</code></pre>
<p><span class="citation" data-cites="section">@section</span> gsrmail Lwsgs Email configuration</p>
<p>lwsgs will can send emails by talking to an SMTP server on localhost:25. That will usually be sendmail or postfix, you should confirm that works first by itself using the <code>mail</code> application to send on it.</p>
<p>lwsgs has been tested on stock Fedora sendmail and postfix.</p>
<p><span class="citation" data-cites="section">@section</span> gsap Lwsgs Integration with another protocol</p>
<p>lwsgs is designed to provide sessions and accounts in a standalone and generic way.</p>
<p>But it’s not useful by itself, there will always be the actual application who wants to make use of generic-sessions features.</p>
<p>We provide the “messageboard” plugin as an example of how to integrate with your actual application protocol.</p>
<p>The basic approach is the ‘real’ protocol handler (usually a plugin itself) subclasses the generic-sessions plugin and calls through to it by default.</p>
<p>The “real” protocol handler entirely deals with ws-related stuff itself, since generic-sessions does not use ws. But for</p>
<ul>
<li>LWS_CALLBACK_HTTP</li>
<li>LWS_CALLBACK_HTTP_BODY</li>
<li>LWS_CALLBACK_HTTP_BODY_COMPLETION</li>
<li>LWS_CALLBACK_HTTP_DROP_PROTOCOL</li>
</ul>
<p>the “real” protocol handler checks if it recognizes the activity (eg, his own POST form URL) and if not, passes stuff through to the generic-sessions protocol callback to handle it. To simplify matters the real protocol can just pass through any unhandled messages to generic-sessions.</p>
<p>The “real” protocol can get a pointer to generic-sessions protocol on the same vhost using</p>
<pre><code>    vhd-&gt;gsp = lws_vhost_name_to_protocol(vhd-&gt;vh, &quot;protocol-generic-sessions&quot;);</code></pre>
<p>The “real” protocol must also arrange generic-sessions per_session_data in his own per-session allocation. To allow keeping generic-sessions opaque, the real protocol must allocate that space at runtime, using the pss size the generic-sessions protocol struct exposes</p>
<pre><code>    struct per_session_data__myapp {
        void *pss_gs;
    ...
    
        pss-&gt;pss_gs = malloc(vhd-&gt;gsp-&gt;per_session_data_size);</code></pre>
<p>The allocation reserved for generic-sessions is then used as user_space when the real protocol calls through to the generic-sessions callback</p>
<pre><code>    vhd-&gt;gsp-&gt;callback(wsi, reason, &amp;pss-&gt;pss_gs, in, len);</code></pre>
<p>In that way the “real” protocol can subclass generic-sessions functionality.</p>
<p>To ease management of these secondary allocations, there are callbacks that occur when a wsi binds to a protocol and when the binding is dropped. These should be used to malloc and free and kind of per-connection secondary allocations.</p>
<pre><code>    case LWS_CALLBACK_HTTP_BIND_PROTOCOL:
        if (!pss || pss-&gt;pss_gs)
            break;

        pss-&gt;pss_gs = malloc(vhd-&gt;gsp-&gt;per_session_data_size);
        if (!pss-&gt;pss_gs)
            return -1;

        memset(pss-&gt;pss_gs, 0, vhd-&gt;gsp-&gt;per_session_data_size);
        break;

    case LWS_CALLBACK_HTTP_DROP_PROTOCOL:
        if (vhd-&gt;gsp-&gt;callback(wsi, reason, pss ? pss-&gt;pss_gs : NULL, in, len))
            return -1;

        if (pss-&gt;pss_gs) {
            free(pss-&gt;pss_gs);
            pss-&gt;pss_gs = NULL;
        }
        break;</code></pre>
<p>#section gsapsib Getting session-specific information from another protocol</p>
<p>At least at the time when someone tries to upgrade an http(s) connection to ws(s) with your real protocol, it is necessary to confirm the cookie the http(s) connection has with generic-sessions and find out his username and other info.</p>
<p>Generic sessions lets another protocol check it again by calling his callback, and lws itself provides a generic session info struct to pass the related data</p>
<pre><code>    struct lws_session_info {
        char username[32];
        char email[100];
        char ip[72];
        unsigned int mask;
        char session[42];
    };

    struct lws_session_info sinfo;
    ...
    vhd-&gt;gsp-&gt;callback(wsi, LWS_CALLBACK_SESSION_INFO,
                   &amp;pss-&gt;pss_gs, &amp;sinfo, 0);</code></pre>
<p>After the call to generic-sessions, the results can be</p>
<ul>
<li><p>all the strings will be zero-length and .mask zero, there is no usable cookie</p></li>
<li><p>only .ip and .session are set: the cookie is OK but no user logged in</p></li>
<li><p>all the strings contain information about the logged-in user</p></li>
</ul>
<p>the real protocol can use this to reject attempts to open ws connections from http connections that are not authenticated; afterwards there’s no need to check the ws connection auth status again.</p>
</body>
</html>
