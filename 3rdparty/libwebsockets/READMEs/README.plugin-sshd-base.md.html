<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README.plugin-sshd-base</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="ssh-base-plugin">ssh-base Plugin</h1>
<h2 id="introduction">Introduction</h2>
<p>lws-ssh-base is a protcol plugin for libwebsockets that implements a generic, abstract, ssh server.</p>
<ul>
<li><p>very small footprint in code and memory, takes up small part of ESP32</p></li>
<li><p>written with security in mind: valgrind and Coverity -clean</p></li>
<li><p>binds to one or more vhosts, that controls listen port(s)</p></li>
<li><p>all IO and settings abstracted through a single “ops” struct from user code</p></li>
<li><p>each instance on a vhost has its own “ops” struct, defining server keys, auth method and functions to implement IO and other operations</p></li>
<li><p>The plugin has no built-in behaviours like check ~/.ssh/authorized_keys, treat auth usernames as system usernames, or spawn the user’s shell. Everything potentially dangerous is left to the user ops code to decide how to handle. It’s NOT like sshd where running it implies it will accept existing keys for any system user, will spawn a shell, etc, unless you implement those parts in the ops callbacks.</p></li>
<li><p>The plugin requires extra code around it in the form of the ops struct handlers. So it’s role is something like an abstract base class for an ssh server. All the crypto, protocol sequencing and state machine are inside, but all the IO except the network connection is outside.</p></li>
<li><p>Built as part of libwebsockets, like all plugins may be dynamically loaded at runtime or built statically. Test app <code>libwebsockets-test-sshd</code> provided</p></li>
<li><p>Uses hash and RSA functions from either mbedTLS or OpenSSL automatically, according to which library libwebsockets was built for</p></li>
</ul>
<p>To maintain its small size, it implements a single “best of breed” crypto for the following functions:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Crypto</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>KEX</td>
<td>curve25519-sha256@libssh.org</td>
</tr>
<tr class="even">
<td>Server host key</td>
<td>ssh-rsa (4096b)</td>
</tr>
<tr class="odd">
<td>Encryption</td>
<td>chacha20-poly1305@openssh.com</td>
</tr>
<tr class="even">
<td>Compression</td>
<td>None</td>
</tr>
</tbody>
</table>
<h2 id="license">License</h2>
<p>lws-ssh-base is Free Software, available under libwebsocket’s LGPLv2 + static linking exception license.</p>
<p>The crypto parts are available elsewhere under a BSD license. But for simplicity the whole plugin is under LGPLv2.</p>
<h2 id="generating-your-own-keys">Generating your own keys</h2>
<pre><code> $ ssh-keygen -t rsa -b 4096 -f mykeys</code></pre>
<p>will ask for a passphrase and generate the private key in <code>mykeys</code> and the public key in <code>mykeys.pub</code>. If you already have a suitable RSA key you use with ssh, you can just use that directly.</p>
<p>lws installs a test keypair in /usr[/local]/share/libwebsockets-test-server that the test apps will accept.</p>
<h2 id="example-code">Example code</h2>
<ol type="1">
<li>There’s a working example app <code>libwebsockets-test-sshd</code> included that spawns a bash shell when an ssh client authenticates. The username used on the remote ssh has no meaning, it spawns the shell under the credentials of “lws-test-sshd” was run under. It accepts the lws ssh test key which is installed into /usr[/local]/share/libwebsockets-test-server.</li>
</ol>
<p>Start the server like this (it wants root only because the server key is stored in /etc)</p>
<pre><code> $ sudo libwebsockets-test-sshd</code></pre>
<p>Connect to it using the test private key like this</p>
<pre><code> $ ssh -p 2200 -i /usr/local/share/libwebsockets-test-server/lws-ssh-test-keys anyuser@127.0.0.1</code></pre>
<ol start="2" type="1">
<li>There’s also a working example plugin <code>lws-sshd-demo</code> that “subclasses” the abstract <code>lws-ssh-base</code> plugin to make a protocol which can be used from, eg, lwsws. For an lwsws vhost that listens on port 2222 and responds with the lws-sshd-demo ssh server, the related config is:</li>
</ol>
<pre><code>        {
                &quot;name&quot;: &quot;sshd&quot;,
                &quot;port&quot;: &quot;2222&quot;,
                &quot;onlyraw&quot;: &quot;1&quot;,
                &quot;ws-protocols&quot;: [{
                        &quot;lws-ssh-base&quot;: {
                                &quot;status&quot;: &quot;ok&quot;,
                                &quot;ops-from&quot;: &quot;lws-sshd-demo&quot;
                        },
                        &quot;lws-sshd-demo&quot;: {
                                &quot;status&quot;: &quot;ok&quot;,
                                &quot;raw&quot;: &quot;1&quot;
                        }
                }]
        }</code></pre>
<h2 id="integration-to-other-apps">Integration to other apps</h2>
<h3 id="step-0-build-and-install-libwebsockets">Step 0: Build and install libwebsockets</h3>
<p>For the <code>libwebsockets-test-sshd</code> example, you will need CMake options <code>LWS_WITH_CGI</code>, since it uses lws helpers to spawn a shell.</p>
<p>lws-ssh-base itself doesn’t require CGI support in libwebsockets.</p>
<h3 id="step-1-make-the-code-available-in-your-app">Step 1: make the code available in your app</h3>
<p>Include <code>lws-plugin-ssh-base</code> in your app, either as a runtime plugin or by using the lws static include scheme.</p>
<p>To bring in the whole of the ssh-base plugin into your app in one step, statically, just include <code>plugins/ssh-base/include/lws-plugin-sshd-static-build-includes.h</code>, you can see an example of this in <code>./test-apps/test-sshd.c</code>.</p>
<h3 id="step-2-define-your-struct-lws_ssh_ops">Step 2: define your <code>struct lws_ssh_ops</code></h3>
<p><code>plugins/ssh-base/include/lws-plugin-ssh.h</code> defines <code>struct lws_ssh_ops</code> which is used for all customization and integration of the plugin per vhost. Eg,</p>
<pre><code>static const struct lws_ssh_ops ssh_ops = {
    .channel_create         = ssh_ops_channel_create,
    .channel_destroy        = ssh_ops_channel_destroy,
    .tx_waiting         = ssh_ops_tx_waiting,
    .tx             = ssh_ops_tx,
    .rx             = ssh_ops_rx,
    .get_server_key         = ssh_ops_get_server_key,
    .set_server_key         = ssh_ops_set_server_key,
    .set_env            = ssh_ops_set_env,
    .pty_req            = ssh_ops_pty_req,
    .child_process_io       = ssh_ops_child_process_io,
    .child_process_terminated   = ssh_ops_child_process_terminated,
    .exec               = ssh_ops_exec,
    .shell              = ssh_ops_shell,
    .is_pubkey_authorized       = ssh_ops_is_pubkey_authorized,
    .banner             = ssh_ops_banner,
    .disconnect_reason      = ssh_ops_disconnect_reason,
    .server_string          = &quot;SSH-2.0-Libwebsockets&quot;,
    .api_version            = 1,
};</code></pre>
<p>The <code>ssh_ops_...()</code> functions are your implementations for the operations needed by the plugin for your purposes.</p>
<h3 id="step-3-enable-lws-ssh-base-protocol-to-a-vhost-and-configure-using-pvo">Step 3: enable <code>lws-ssh-base</code> protocol to a vhost and configure using pvo</h3>
<p>A pointer to your struct lws_ssh_ops is passed into the vhost instance of the protocol using per-vhost options</p>
<pre><code>static const struct lws_protocol_vhost_options pvo_ssh_ops = {
    NULL,
    NULL,
    &quot;ops&quot;,
    (void *)&amp;ssh_ops
};

static const struct lws_protocol_vhost_options pvo_ssh = {
    NULL,
    &amp;pvo_ssh_ops,
    &quot;lws-sshd-base&quot;,
    &quot;&quot; /* ignored, just matches the protocol name above */
};

...
    info.port = 22;
    info.options = LWS_SERVER_OPTION_ONLY_RAW;
    info.vhost_name = &quot;sshd&quot;;
    info.protocols = protocols_sshd;
    info.pvo = &amp;pvo_ssh;

    vh_sshd = lws_create_vhost(context, &amp;info);</code></pre>
<p>There are two possible pvos supported, “ops”, shown above, directly passes the ops structure in using the value on the “ops” pvo.</p>
<p>To support other protocols that want to provide ops to lws-ssh-base themselves for a particular vhost, you can also provide a pvo <code>"ops-from"</code> whose value is the name of the protocol also enabled on this vhost, whose protocol “.user” pointer points to the ops struct lws-ssh-base should use.</p>
<h2 id="integration-to-other-plugins">Integration to other plugins</h2>
<p>A worked example of using the abstract <code>lws-ssh-base</code> plugin from another plugin that provides the ops struct is in <code>./plugins/protocol_lws_sshd_demo</code>.</p>
<p>The key points to note</p>
<ul>
<li><p>the plugin sets the ops struct for the vhost instantiation of <code>lws-ssh-base</code> by passing a pointer to the ops struct in its <code>lws_protocols</code> struct <code>user</code> member.</p></li>
<li><p>the config for the vhost tells <code>lws-ssh-base</code> to pick up the ops struct pointer using an “ops-from” pvo that indicates the protocol name.</p></li>
</ul>
<pre><code>            &quot;lws-ssh-base&quot;: {
                                &quot;status&quot;: &quot;ok&quot;,
                                &quot;ops-from&quot;: &quot;lws-sshd-demo&quot;
                        },</code></pre>
<ul>
<li>the config for the vhost tells lws this vhost only serves RAW (ie, no http)</li>
</ul>
<pre><code>         {
                &quot;name&quot;: &quot;sshd&quot;,
                &quot;port&quot;: &quot;2222&quot;,
                &quot;onlyraw&quot;: &quot;1&quot;,
                ...</code></pre>
<ul>
<li>the config for the vhost marks the protocol that uses <code>lws-ssh-base</code>, not <code>lws-ssh-base</code> itself, as the protocol to be served for raw connections</li>
</ul>
<pre><code>                        &quot;lws-sshd-demo&quot;: {
                                &quot;status&quot;: &quot;ok&quot;,
                                &quot;raw&quot;: &quot;1&quot;
                         ...</code></pre>
<h2 id="notes">Notes</h2>
<p>You can have the vhost it binds to listen on a nonstandard port. The ssh commandline app cane be told to connect to a non-22 port with <code>ssh -p portnum user@hostname</code></p>
</body>
</html>
