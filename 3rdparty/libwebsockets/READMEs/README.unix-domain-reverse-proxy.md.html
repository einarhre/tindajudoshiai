<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README.unix-domain-reverse-proxy</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h2 id="unix-domain-sockets-reverse-proxy">Unix Domain Sockets Reverse Proxy</h2>
<h3 id="introduction">Introduction</h3>
<p>lws is able to use a mount to place reverse proxies into the URL space.</p>
<p>These are particularly useful when using Unix Domain Sockets, basically files in the server filesystem, to communicate between lws and a separate server process and integrate the result into a coherent URL namespace on the lws side. It’s also possible to proxy using tcp sockets.</p>
<figure>
<img src="../doc-assets/http-proxy-overview.svg" alt="overview" /><figcaption>overview</figcaption>
</figure>
<p>This has the advantage that the actual web server that forwards the data from the unix socket owner is in a different process than the server that serves on the unix socket. If it has problems, they do not affect the actual public-facing web server. The unix domain socket server may be in a completely different language than the web server.</p>
<p>Compared to CGI, there are no forks to make a connection to the unix domain socket server.</p>
<h3 id="mount-origin-format">Mount origin format</h3>
<p>Unix Domain Sockets are effectively “files” in the server filesystem, and are defined by their filepath. The “server” side that is to be proxied opens the socket and listens on it, which creates a file in the server filesystem. The socket understands either http or https protocol.</p>
<p>Lws can be told to act as a proxy for that at a mountpoint in the lws vhost url space.</p>
<p>If your mount is expressed in C code, then the mount type is LWSMPRO_HTTP or LWSMPRO_HTTPS depending on the protocol the unix socket understands, and the origin address has the form <code>+/path/to/unix/socket:/path/inside/mount</code>.</p>
<p>The + at the start indicates it is a local unix socket we are proxying, and the ‘:’ acts as a delimiter for the socket path, since unlike other addresses the unix socket path can contain ‘/’ itself.</p>
<h3 id="connectivity-rules-and-translations">Connectivity rules and translations</h3>
<p>Onward proxy connections from lws to the Unix Domain Socket happen using http/1.1. That implies <code>transfer-encoding: chunking</code> in the case that the length of the output is not known beforehand.</p>
<p>Lws takes care of stripping any chunking (which is illegal in h2) and translating between h1 and h2 header formats if the return connection is actually in http/2.</p>
<p>The h1 onward proxy connection translates the following headers from the return connection, which may be h1 or h2:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Header</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>host</td>
<td>Which vhost</td>
</tr>
<tr class="even">
<td>etag</td>
<td>Information on any etag the client has cached for this URI</td>
</tr>
<tr class="odd">
<td>if-modified-since</td>
<td>Information on the freshness of any etag the client has cached for this URI</td>
</tr>
<tr class="even">
<td>accept-language</td>
<td>Which languages the return path client prefers</td>
</tr>
<tr class="odd">
<td>accept-encoding</td>
<td>Which compression encodings the client can accept</td>
</tr>
<tr class="even">
<td>cache-control</td>
<td>Information from the return path client about cache acceptability</td>
</tr>
<tr class="odd">
<td>x-forwarded-for</td>
<td>The IP address of the return path client</td>
</tr>
</tbody>
</table>
<p>This implies that the proxied connection can</p>
<ul>
<li><p>return 301 etc to say the return path client’s etag is still valid</p></li>
<li><p>choose to compress using an acceptable content-encoding</p></li>
</ul>
<p>The following headers are translated from the headers replied via the onward connection (always h1) back to the return path (which may be h1 or h2)</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Header</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>content-length</td>
<td>If present, an assertion of how much payload is expected</td>
</tr>
<tr class="even">
<td>content-type</td>
<td>The mimetype of the payload</td>
</tr>
<tr class="odd">
<td>etag</td>
<td>The canonical etag for the content at this URI</td>
</tr>
<tr class="even">
<td>accept-language</td>
<td>This is returned to the return path client because there is no easy way for the return path client to know what it sent originally. It allows clientside selection of i18n.</td>
</tr>
<tr class="odd">
<td>content-encoding</td>
<td>Any compression format on the payload (selected from what the client sent in accept-encoding, if anything)</td>
</tr>
<tr class="even">
<td>cache-control</td>
<td>The onward server’s response about cacheability of its payload</td>
</tr>
</tbody>
</table>
<h3 id="h1---h2-conversion">h1 -&gt; h2 conversion</h3>
<p>Chunked encoding that may have been used on the outgoing proxy client connection is removed for h2 return connections (chunked encoding is illegal for h2).</p>
<p>Headers are converted to all lower-case and hpack format for h2 return connections.</p>
<p>Header and payload proxying is staged according to when the return connection (which may be an h2 child stream) is writable.</p>
<h3 id="behaviour-if-unix-domain-socket-server-unavailable">Behaviour if unix domain socket server unavailable</h3>
<p>If the server that listens on the unix domain socket is down or being restarted, lws understands that it couldn’t connect to it and returns a clean 503 response <code>HTTP_STATUS_SERVICE_UNAVAILABLE</code> along with a brief human-readable explanation.</p>
<p>The generated status page produced will try to bring in a stylesheet <code>/error.css</code>. This allows you to produce a styled error pages with logos, graphics etc. See <a href="https://libwebsockets.org/git/badrepo">this</a> for an example of what you can do with it.</p>
</body>
</html>
