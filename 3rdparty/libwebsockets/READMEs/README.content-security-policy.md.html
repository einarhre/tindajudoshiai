<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README.content-security-policy</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h2 id="using-content-security-policy-csp">Using Content Security Policy (CSP)</h2>
<h3 id="what-is-it">What is it?</h3>
<p>Modern browsers have recently implemented a new feature providing a sort of “selinux for your web page”. If the server sends some new headers describing the security policy for the content, then the browser strictly enforces it.</p>
<h3 id="why-would-we-want-to-do-that">Why would we want to do that?</h3>
<p>Scripting on webpages is pretty universal, sometimes the scripts come from third parties, and sometimes attackers find a way to inject scripts into the DOM, eg, through scripts in content.</p>
<p>CSP lets the origin server define what is legitimate for the page it served and everything else is denied.</p>
<p>The CSP for warmcat.com and libwebsockets.org looks like this, I removed a handful of whitelisted image sources like travis status etc for clarity…</p>
<pre><code>&quot;content-security-policy&quot;: &quot;default-src &#39;none&#39;; img-src &#39;self&#39; data:; script-src &#39;self&#39;; font-src &#39;self&#39;; style-src &#39;self&#39;; connect-src &#39;self&#39;; frame-ancestors &#39;none&#39;; base-uri &#39;none&#39;;&quot;,
&quot;x-content-type-options&quot;: &quot;nosniff&quot;,
&quot;x-xss-protection&quot;: &quot;1; mode=block&quot;,
&quot;x-frame-options&quot;: &quot;deny&quot;,
&quot;referrer-policy&quot;: &quot;no-referrer&quot;</code></pre>
<p>The result of this is the browser won’t let the site content be iframed, and it will reject any inline styles or inline scripts. Fonts, css, ajax, ws and images are only allowed to come from ‘self’, ie, the server that served the page. You may inject your script, or deceptive styles: it won’t run or be shown.</p>
<p>Because inline scripts are banned, the usual methods for XSS are dead; the attacker can’t even load js from another server. So these rules provide a very significant increase in client security.</p>
<h3 id="implications-of-strict-csp">Implications of strict CSP</h3>
<p>Halfhearted CSP isn’t worth much. The only useful approach is to start with <code>default-src 'none'</code> which disables everything, and then whitelist the minimum needed for the pages to operate.</p>
<p>“Minimum needed for the pages to operate” doesn’t mean defeat the protections necessary so everything in the HTML can stay the same… it means adapt the pages to want the minimum and then enable the minimum.</p>
<p>The main point is segregation of styles and script away from the content, in files referenced in the document <code>&lt;head&gt;</code> section, along these lines:</p>
<pre><code>&lt;head&gt;
 &lt;meta charset=utf-8 http-equiv=&quot;Content-Language&quot; content=&quot;en&quot;/&gt;
 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;test.css&quot;/&gt;
 &lt;script type=&#39;text/javascript&#39; src=&quot;/lws-common.js&quot;&gt;&lt;/script&gt;
 &lt;script type=&#39;text/javascript&#39; src=&#39;test.js&#39;&gt;&lt;/script&gt;
 &lt;title&gt;Minimal Websocket test app&lt;/title&gt;
&lt;/head&gt;</code></pre>
<h4 id="inline-styles-must-die">Inline styles must die</h4>
<p>All styling must go in one or more <code>.css</code> file(s) best served by the same server… while you can whitelist other sources in the CSP if you have to, unless you control that server as well, you are allowing whoever gains access to that server access to your users.</p>
<p>Inline styles are no longer allowed (eg, “style=‘font-size:120%’” in the HTML)… they must be replaced by reference to one or more CSS class, which in this case includes “font-size:120%”. This has always been the best practice anyway, and your pages will be cleaner and more maintainable.</p>
<h4 id="inline-scripts-must-die">Inline scripts must die</h4>
<p>Inline scripts need to be placed in a <code>.js</code> file and loaded in the page head section, again it should only be from the server that provided the page.</p>
<p>Then, any kind of inline script, yours or injected or whatever, will be completely rejected by the browser.</p>
<h4 id="onxxx-must-be-replaced-by-eventlistener">onXXX must be replaced by eventListener</h4>
<p>Inline <code>onclick()</code> etc are kinds of inline scripting and are banned.</p>
<p>Modern browsers have offered a different system called <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventListener">“EventListener” for a while</a> which allows binding of events to DOM elements in JS.</p>
<p>A bunch of different named events are possible to listen on, commonly the <code>.js</code> file will ask for one or both of</p>
<pre><code>window.addEventListener(&quot;load&quot;, function() {
...
}, false);

document.addEventListener(&quot;DOMContentLoaded&quot;, function() {
...
}, false);</code></pre>
<p>These give the JS a way to trigger when either everything on the page has been “loaded” or the DOM has been populated from the initial HTML. These can set up other event listeners on the DOM objects and aftwards the events will drive what happens on the page from user interaction and / or timers etc.</p>
<p>If you have <code>onclick</code> in your HTML today, you would replace it with an id for the HTML element, then eg in the DOMContentLoaded event listener, apply</p>
<pre><code>   document.getElementById(&quot;my-id&quot;).addEventListener(&quot;click&quot;, function() {
   ...
   }, false);</code></pre>
<p>ie the .js file becomes the only place with the “business logic” of the elements mentioned in the HTML, applied at runtime.</p>
<h4 id="do-you-really-need-external-sources">Do you really need external sources?</h4>
<p>Do your scripts and fonts really need to come from external sources? If your caching policy is liberal, they are not actually that expensive to serve once and then the user is using his local copy for the next days.</p>
<p>Some external sources are marked as anti-privacy in modern browsers, meaning they track your users, in turn meaning if your site refers to them, you will lose your green padlock in the browser. If the content license allows it, hosting them on “self”, ie, the same server that provided the HTML, will remove that problem.</p>
<p>Bringing in scripts from external sources is actually quite scary from the security perspective. If someone hacks the <code>ajax.googleapis.com</code> site to serve a hostile, modified jquery, half the Internet will instantly become malicious. However if you serve it yourself, unless your server was specifically targeted you know it will continue to serve what you expect.</p>
<p>Since these scripts are usually sent with cache control headers for local caching duration of 1 year, the cost of serving them yourself under the same conditions is small but your susceptibility to attack is reduced to only taking care of your own server. And there is a privacy benefit that google is not informed of your users’ IPs and activities on your site.</p>
</body>
</html>
