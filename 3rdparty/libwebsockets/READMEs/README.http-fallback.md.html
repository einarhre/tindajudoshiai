<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README.http-fallback</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="http-fallback-and-raw-proxying">Http fallback and raw proxying</h1>
<p>Lws has several interesting options and features that can be applied to get some special behaviours… this article discusses them and how they work.</p>
<h2 id="overview-of-normal-vhost-selection">Overview of normal vhost selection</h2>
<p>Lws supports multiple http or https vhosts sharing a listening socket on the same port.</p>
<p>For unencrypted http, the Host: header is used to select which vhost the connection should bind to, by comparing what is given there against the names the server was configured with for the various vhosts. If no match, it selects the first configured vhost.</p>
<p>For TLS, it has an extension called SNI (Server Name Indication) which tells the server early in the TLS handshake the host name the connection is aimed at. That allows lws to select the vhost early, and use vhost-specific TLS certs so everything is happy. Again, if there is no match the connection proceeds using the first configured vhost and its certs.</p>
<h2 id="https-fallback-options">Http(s) fallback options</h2>
<p>What happens if you try to connect, eg, an ssh client to the http server port (this is not an idle question…)? Obviously the http server part or the tls part of lws will fail the connection and close it. (We will look at that flow in a moment in detail for both unencrypted and tls listeners.)</p>
<p>However if the first configured vhost for the port was created with the vhost creation info struct <code>.options</code> flag <code>LWS_SERVER_OPTION_FALLBACK_TO_APPLY_LISTEN_ACCEPT_CONFIG</code>, then instead of the error, the connection transitions to whatever role was given in the vhost creation info struct <code>.listen_accept_role</code> and <code>.listen_accept_protocol</code>.</p>
<p>With lejp-conf / lwsws, the options can be applied to the first vhost using:</p>
<pre><code>   &quot;listen-accept-role&quot;: &quot;the-role-name&quot;,
   &quot;listen-accept-protocol&quot;: &quot;the-protocol-name&quot;,
   &quot;fallback-listen-accept&quot;: &quot;1&quot;</code></pre>
<p>See <code>./minimal-examples/raw/minimal-raw-fallback-http-server</code> for examples of all the options in use via commandline flags.</p>
<p>So long as the first packet for the protocol doesn’t look like GET, POST, or a valid tls packet if connection to an https vhost, this allows the one listen socket to handle both http(s) and a second protocol, as we will see, like ssh.</p>
<p>Notice there is a restriction that no vhost selection processing is possible, neither for tls listeners nor plain http ones… the packet belonging to a different protocol will not send any Host: header nor tls SNI.</p>
<p>Therefore although the flags and settings are applied to the first configured vhost, actually their effect is global for a given listen port. If enabled, all vhosts on the same listen port will do the fallback action.</p>
<h3 id="plain-http-flow">Plain http flow</h3>
<figure>
<img src="/doc-assets/accept-flow-1.svg" alt="plain http flow" /><figcaption>plain http flow</figcaption>
</figure>
<p>Normally, if the first received packet does not contain a valid HTTP method, then the connection is dropped. Which is what you want from an http server.</p>
<p>However if enabled, the connection can transition to the defined secondary role / protocol.</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Flag</th>
<th>lejp-conf / lwsws</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>LWS_SERVER_OPTION_FALLBACK_TO_APPLY_LISTEN_ACCEPT_CONFIG</code></td>
<td><code>"fallback-listen-accept": "1"</code></td>
<td>Enable fallback processing</td>
</tr>
</tbody>
</table>
<h3 id="tls-https-flow">TLS https flow</h3>
<figure>
<img src="/doc-assets/accept-flow-2.svg" alt="tls https flow" /><figcaption>tls https flow</figcaption>
</figure>
<p>If the port is listening with tls, the point that a packet from a different protocol will fail is earlier, when the tls tunnel is being set up.</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Flag</th>
<th>lejp-conf / lwsws</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>LWS_SERVER_OPTION_FALLBACK_TO_APPLY_LISTEN_ACCEPT_CONFIG</code></td>
<td><code>"fallback-listen-accept": "1"</code></td>
<td>Enable fallback processing</td>
</tr>
<tr class="even">
<td><code>LWS_SERVER_OPTION_REDIRECT_HTTP_TO_HTTPS</code></td>
<td><code>"redirect-http": "1"</code></td>
<td>Treat invalid tls packet as http, issue http redirect to https://</td>
</tr>
<tr class="odd">
<td><code>LWS_SERVER_OPTION_ALLOW_HTTP_ON_HTTPS_LISTENER</code></td>
<td><code>"allow-http-on-https": "1"</code></td>
<td>Accept unencrypted http connections on this tls port (dangerous)</td>
</tr>
</tbody>
</table>
<p>The latter two options are higher priority than, and defeat, the first one.</p>
<h3 id="non-http-listener">Non-http listener</h3>
<figure>
<img src="/doc-assets/accept-flow-3.svg" alt="non-http flow" /><figcaption>non-http flow</figcaption>
</figure>
<p>It’s also possible to skip the fallback processing and just force the first vhost on the port to use the specified role and protocol in the first place.</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Flag</th>
<th>lejp-conf / lwsws</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LWS_SERVER_OPTION_ADOPT_APPLY_LISTEN_ACCEPT_CONFIG</td>
<td><code>"apply-listen-accept": "1"</code></td>
<td>Force vhost to use listen-accept-role / listen-accept-protocol</td>
</tr>
</tbody>
</table>
<h2 id="using-https-fallback-with-raw-proxy">Using http(s) fallback with raw-proxy</h2>
<p>If enabled for build with <code>cmake .. -DLWS_ROLE_RAW_PROXY=1 -DLWS_WITH_PLUGINS=1</code> then lws includes ready-to-use support for raw tcp proxying.</p>
<p>This can be used standalone on the first vhost on a port, but most intriguingly it can be specified as the fallback for http(s)…</p>
<p>See <code>./minimal-examples/raw/minimal-raw-proxy-fallback.c</code> for a working example.</p>
<h3 id="fallback-with-raw-proxy-in-code">fallback with raw-proxy in code</h3>
<p>On the first vhost for the port, specify the required “onward” pvo to configure the raw-proxy protocol…you can adjust the “ipv4:127.0.0.1:22” to whatever you want…</p>
<pre><code>    static struct lws_protocol_vhost_options pvo1 = {
            NULL,
            NULL,
            &quot;onward&quot;,       /* pvo name */
            &quot;ipv4:127.0.0.1:22&quot; /* pvo value */
    };

    static const struct lws_protocol_vhost_options pvo = {
            NULL,               /* &quot;next&quot; pvo linked-list */
            &amp;pvo1,          /* &quot;child&quot; pvo linked-list */
            &quot;raw-proxy&quot;,        /* protocol name we belong to on this vhost */
            &quot;&quot;                  /* ignored */
    };</code></pre>
<p>… and set up the fallback enable and bindings…</p>
<pre><code>    info.options |= LWS_SERVER_OPTION_FALLBACK_TO_APPLY_LISTEN_ACCEPT_CONFIG;
    info.listen_accept_role = &quot;raw_proxy&quot;;
    info.listen_accept_proxy = &quot;raw_proxy&quot;;
    info.pvo = &amp;pvo;</code></pre>
<h3 id="fallback-with-raw-proxy-in-json-conf">fallback with raw-proxy in JSON conf</h3>
<p>On the first vhost for the port, enable the raw-proxy protocol on the vhost and set the pvo config</p>
<pre><code>                &quot;ws-protocols&quot;: [{
                        &quot;raw-proxy&quot;: {
                         &quot;status&quot;: &quot;ok&quot;,
                         &quot;onward&quot;: &quot;ipv4:127.0.0.1:22&quot;
                        }
                 }],</code></pre>
<p>Enable the fallback behaviour on the vhost and the role / protocol binding</p>
<pre><code>    &quot;listen-accept-role&quot;: &quot;raw-proxy&quot;,
    &quot;listen-accept-protocol&quot;: &quot;raw-proxy&quot;,
    &quot;fallback-listen-accept&quot;: &quot;1&quot;</code></pre>
<h3 id="testing">Testing</h3>
<p>With this configured, the listen port will function normally for http or https depending on how it was set up.</p>
<p>But if you try to connect to it with an ssh client, that will also work fine.</p>
<p>The libwebsockets.org server is set up in this way, you can confirm it by visiting <code>https://libwebsockets.org</code> on port 443 as usual, but also trying <code>ssh -p 443 invalid@libwebsockets.org</code>… you will get permission denied from your ssh client. With valid credentials in fact that works perfectly for ssh, scp, git-over-ssh etc all on port 443…</p>
</body>
</html>
